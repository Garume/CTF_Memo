from Crypto.Util.number import *

rq = 19810366367306768644232525389747537275045405439314176008633941392973721570576
e = 2003
n = 53664914438946444484927033862034379455718178099855523463910489141278737139791364848208743006407518112277320817669787439691746610553268296914262444216919462704386000709590354290776125186391163453068896662299911360086707554877293931251419654653697668300856682339771668434126765552712459921497413416092669041767
s = 1265360460709769693851512645319061903059544747651255568642678113569298391357942430157526652399779965777773923822682724660363135543391240091671
cipher = 3525641216292044326230126878010965135622104164889473380631987836858540038157143138676142725091457076602363325805674619659098806219641234241974545976708403653241036734687378559603323103895230661957412111732445158813275702605408361822949263056812334913257113499719211581915694082795450665196587909415670111499

shift = 2^470
for k in range(1, e):
    print(f"[*] {k} / {e}")
    F.<x> = PolynomialRing(Zmod(n))
    f = e*(x*shift + s) - 1 + k*rq - k
    f = f.monic()
    x0 = f.small_roots(X=2^42, beta=0.20, epsylon=1/16)
    if len(x0) != 0:
        d_ = int(x0[0])*shift + s 
        print("ok")
        break


var("r")
fr = 1 + k*(r - rq - 1)*(r - 1) - e*d_
print(solve(fr, r))